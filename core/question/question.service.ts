import { Question, QuestionEntity } from './question.entity';
import { IQuestionRepository } from './question.repository';
import { NotFoundError } from '../shared/errors';

/**
 * Question Service - Business logic for question management
 * Handles CRUD for all 8 question types and question utilities
 */
export class QuestionService {
  constructor(private repository: IQuestionRepository) {}

  /**
   * Create a new question
   */
  async createQuestion(data: {
    text: string;
    type: string;
    difficulty: 'easy' | 'medium' | 'hard';
    points: number;
    explanation?: string;
    categoryIds?: string[];
    tags?: string[];
    optionIds?: string[];
    correctOptionId?: string;
    correctOptionIds?: string[];
    correctAnswer?: boolean;
    correctAnswers?: string[];
    blankCount?: number;
    correctNumber?: number;
    tolerance?: number;
    itemIds?: string[];
    correctOrder?: string[];
    leftItemIds?: string[];
    rightItemIds?: string[];
    correctPairs?: Record<string, string>;
  }): Promise<Question> {
    // Validate points
    if (data.points < 1 || data.points > 100) {
      throw new Error('Points must be between 1 and 100');
    }

    // Validate based on type
    this.validateQuestionType(data);

    const question = QuestionEntity.create({
      id: '', // Will be generated by repository
      text: data.text,
      type: data.type,
      difficulty: data.difficulty,
      points: data.points,
      explanation: data.explanation,
      categoryIds: data.categoryIds || [],
      tags: data.tags || [],
      ...(data.type === 'single_choice' && {
        optionIds: data.optionIds || [],
        correctOptionId: data.correctOptionId,
      }),
      ...(data.type === 'multiple_choice' && {
        optionIds: data.optionIds || [],
        correctOptionIds: data.correctOptionIds || [],
      }),
      ...(data.type === 'true_false' && {
        correctAnswer: data.correctAnswer,
      }),
      ...(data.type === 'fill_blank' && {
        correctAnswers: data.correctAnswers || [],
        blankCount: data.blankCount || 1,
      }),
      ...(data.type === 'cloze_test' && {
        correctAnswers: data.correctAnswers || [],
      }),
      ...(data.type === 'numeric_input' && {
        correctNumber: data.correctNumber,
        tolerance: data.tolerance || 0,
      }),
      ...(data.type === 'ordering' && {
        itemIds: data.itemIds || [],
        correctOrder: data.correctOrder || [],
      }),
      ...(data.type === 'matching' && {
        leftItemIds: data.leftItemIds || [],
        rightItemIds: data.rightItemIds || [],
        correctPairs: data.correctPairs || {},
      }),
      createdAt: new Date(),
      updatedAt: new Date(),
    } as any);

    return this.repository.create(question);
  }

  /**
   * Get question by ID
   */
  async getQuestionById(id: string): Promise<Question> {
    const question = await this.repository.findById(id);
    if (!question) {
      throw new NotFoundError('Question', id);
    }
    return question;
  }

  /**
   * Update question
   */
  async updateQuestion(id: string, data: Partial<Question>): Promise<Question> {
    const question = await this.getQuestionById(id);

    // Validate if type-specific fields are being updated
    if (data.type && data.type !== question.type) {
      throw new Error('Cannot change question type');
    }

    if (data.points && (data.points < 1 || data.points > 100)) {
      throw new Error('Points must be between 1 and 100');
    }

    const updated = await this.repository.update(id, {
      ...data,
      updatedAt: new Date(),
    });

    return updated;
  }

  /**
   * Get questions by quiz
   */
  async getQuestionsByQuiz(quizId: string): Promise<Question[]> {
    return this.repository.findByQuizId(quizId);
  }

  /**
   * Get questions by category
   */
  async getQuestionsByCategory(categoryId: string): Promise<Question[]> {
    return this.repository.findByCategory(categoryId);
  }

  /**
   * Get questions by type
   */
  async getQuestionsByType(type: string): Promise<Question[]> {
    return this.repository.findByType(type);
  }

  /**
   * Get all questions with pagination
   */
  async getAllQuestions(
    page: number = 1,
    limit: number = 10
  ): Promise<{ items: Question[]; total: number }> {
    return this.repository.findAll(page, limit);
  }

  /**
   * Get questions by difficulty
   */
  async getQuestionsByDifficulty(difficulty: 'easy' | 'medium' | 'hard'): Promise<Question[]> {
    const allQuestions = await this.repository.findAll(1, 10000);
    return allQuestions.items.filter((q) => q.difficulty === difficulty);
  }

  /**
   * Delete question
   */
  async deleteQuestion(id: string): Promise<void> {
    await this.getQuestionById(id);
    await this.repository.delete(id);
  }

  /**
   * Validate question type-specific fields
   */
  private validateQuestionType(data: any): void {
    switch (data.type) {
      case 'single_choice':
        if (!data.optionIds || data.optionIds.length === 0) {
          throw new Error('Single choice question must have options');
        }
        if (!data.correctOptionId) {
          throw new Error('Single choice question must have a correct option');
        }
        break;

      case 'multiple_choice':
        if (!data.optionIds || data.optionIds.length === 0) {
          throw new Error('Multiple choice question must have options');
        }
        if (!data.correctOptionIds || data.correctOptionIds.length === 0) {
          throw new Error('Multiple choice question must have correct options');
        }
        break;

      case 'true_false':
        if (data.correctAnswer === undefined) {
          throw new Error('True/False question must have a correct answer');
        }
        break;

      case 'fill_blank':
        if (!data.correctAnswers || data.correctAnswers.length === 0) {
          throw new Error('Fill blank question must have correct answers');
        }
        break;

      case 'cloze_test':
        if (!data.correctAnswers || data.correctAnswers.length === 0) {
          throw new Error('Cloze test question must have correct answers');
        }
        break;

      case 'numeric_input':
        if (data.correctNumber === undefined) {
          throw new Error('Numeric input question must have a correct number');
        }
        break;

      case 'ordering':
        if (!data.itemIds || data.itemIds.length === 0) {
          throw new Error('Ordering question must have items');
        }
        if (!data.correctOrder || data.correctOrder.length === 0) {
          throw new Error('Ordering question must have correct order');
        }
        break;

      case 'matching':
        if (!data.leftItemIds || data.leftItemIds.length === 0) {
          throw new Error('Matching question must have left items');
        }
        if (!data.rightItemIds || data.rightItemIds.length === 0) {
          throw new Error('Matching question must have right items');
        }
        if (!data.correctPairs || Object.keys(data.correctPairs).length === 0) {
          throw new Error('Matching question must have correct pairs');
        }
        break;
    }
  }

  /**
   * Check if question type is multiple answer
   */
  isMultipleAnswer(question: Question): boolean {
    return QuestionEntity.isMultipleAnswer(question);
  }

  /**
   * Check if question type is single answer
   */
  isSingleAnswer(question: Question): boolean {
    return QuestionEntity.isSingleAnswer(question);
  }

  /**
   * Check if question type is ordering
   */
  isOrdering(question: Question): boolean {
    return QuestionEntity.isOrdering(question);
  }

  /**
   * Check if question type is matching
   */
  isMatching(question: Question): boolean {
    return QuestionEntity.isMatching(question);
  }
}
